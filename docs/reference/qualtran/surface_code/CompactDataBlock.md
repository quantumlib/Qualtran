# CompactDataBlock
`qualtran.surface_code.CompactDataBlock`


<table class="tfo-notebook-buttons tfo-api nocontent" align="left">
<td>
  <a target="_blank" href="https://github.com/quantumlib/Qualtran/blob/main/qualtran/surface_code/data_block.py#L150-L174">
    <img src="https://www.tensorflow.org/images/GitHub-Mark-32px.png" />
    View source on GitHub
  </a>
</td>
</table>



The compact data block uses a fixed code distance and one, long access hallway.

Inherits From: [`DataBlock`](../../qualtran/surface_code/DataBlock.md)

<section class="expandable">
  <h4 class="showalways">View aliases</h4>
  <p>
<b>Main aliases</b>
<p>`qualtran.surface_code.data_block.CompactDataBlock`</p>
</p>
</section>

<pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link">
<code>qualtran.surface_code.CompactDataBlock(
    data_d
)
</code></pre>



<!-- Placeholder for "Used in" -->

The compact data block lays $n$ qubit batches in grid of shape (3, $n/2$) where
the data batches are lined in the first and last row with the middle row being
an ancilla region. This lowers the space footprint of the block at the cost of an
increased number of cycles to consume a magic state.

<h2 class="add-link">References</h2>






<h2 class="add-link">Attributes</h2>

`data_d`<a id="data_d"></a>
: The code distance `d` for protecting the qubits in the data block.

`n_steps_to_consume_a_magic_state`<a id="n_steps_to_consume_a_magic_state"></a>
: The number of surface code steps to consume a magic state.
  
  We must teleport in "magic states" to do non-Clifford operations on our algorithmic
  data qubits. The layout of the data block can limit the number magic states consumed
  per unit time.
  
  One surface code step is `data_d` cycles of error correction.
  
  DataBlock imlpementation must override this method. This method is used by
  `self.n_cycles` to report the total number of cycles required.




## Methods

<h3 id="n_tiles"><code>n_tiles</code></h3>

<a target="_blank" class="external" href="https://github.com/quantumlib/Qualtran/blob/main/qualtran/surface_code/data_block.py#L169-L170">View source</a>

<pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link">
<code>n_tiles(
    n_algo_qubits: int
) -> int
</code></pre>

The number of surface code tiles used to store a given number of algorithm qubits.

 We define an “algorithm qubit” to be a qubit used in the routing of algorithm-relevant
 quantum data in a bloq. A physical qubit is a physical system that can encode one qubit,
 albeit noisily. Specific to the surface code, we define a “tile” to be the minimal area
 of physical qubits necessary to encode one logical qubit to a particular code distance.
 A tile can store an algorithm qubit, can be used for ancillary purposes like routing,
 or can be left idle. A tile is usually a square grid of $2d^2$ physical qubits.

 DataBlock implementations must override this method. This method is used by
 `self.n_phys_qubits` to report the total number of physical qubits.

Args

`n_algo_qubits`
: The number of algorithm qubits to compute the number of tiles for.




Returns




<h3 id="__ne__"><code>__ne__</code></h3>

<pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link">
<code>__ne__(
    other
)
</code></pre>

Check equality and either forward a NotImplemented or return the result negated.


<h3 id="__eq__"><code>__eq__</code></h3>

<pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link">
<code>__eq__(
    other
)
</code></pre>

Method generated by attrs for class CompactDataBlock.




