# QubitCount
`qualtran.resource_counting.QubitCount`


<table class="tfo-notebook-buttons tfo-api nocontent" align="left">
<td>
  <a target="_blank" href="https://github.com/quantumlib/Qualtran/blob/main/qualtran/resource_counting/_qubit_counts.py#L79-L146">
    <img src="https://www.tensorflow.org/images/GitHub-Mark-32px.png" />
    View source on GitHub
  </a>
</td>
</table>



A cost estimating the number of qubits required to implement a bloq.

Inherits From: [`CostKey`](../../qualtran/resource_counting/CostKey.md)

<pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link">
<code>qualtran.resource_counting.QubitCount()
</code></pre>



<!-- Placeholder for "Used in" -->

The number of qubits is bounded from below by the number of qubits implied by the signature.
If a bloq has no callees, the size implied by the signature will be returned. Otherwise,
this CostKey will try to compute the number of qubits by inspecting the decomposition.

In the decomposition, each (sub)bloq is considered to be executed sequentially. The "width"
of the circuit (i.e. the number of qubits) at each sequence point is the number of qubits
required by the subbloq (computed recursively) plus any "bystander" idling wires.

This is an estimate for the number of qubits required by an algorithm. Specifically:
 - Bloqs are assumed to be executed sequentially, minimizing the number of qubits potentially
   at the expense of greater circuit depth or execution time.
 - We do not consider "tetris-ing" subbloqs. In a decomposition, each subbloq is assumed
   to be using all of its qubits for the duration of its execution. This could potentially
   overestimate the total number of qubits.

This Min-Max style estimate can provide a good balance between accuracy and scalability
of the accounting. To fully account for each qubit and manage space-vs-time trade-offs,
you must comprehensively decompose your algorithm to a `cirq.Circuit` of basic gates and
use a `cirq.QubitManager` to manage trade-offs. This may be computationally expensive for
large algorithms.

## Methods

<h3 id="compute"><code>compute</code></h3>

<a target="_blank" class="external" href="https://github.com/quantumlib/Qualtran/blob/main/qualtran/resource_counting/_qubit_counts.py#L105-L139">View source</a>

<pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link">
<code>compute(
    bloq: 'Bloq', get_callee_cost: Callable[['Bloq'], SymbolicInt]
) -> <a href="../../qualtran/symbolics/SymbolicInt.html"><code>qualtran.symbolics.SymbolicInt</code></a>
</code></pre>

Compute an estimate of the number of qubits used by `bloq`.

See the class docstring for more information.

<h3 id="zero"><code>zero</code></h3>

<a target="_blank" class="external" href="https://github.com/quantumlib/Qualtran/blob/main/qualtran/resource_counting/_qubit_counts.py#L141-L143">View source</a>

<pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link">
<code>zero() -> <a href="../../qualtran/symbolics/SymbolicInt.html"><code>qualtran.symbolics.SymbolicInt</code></a>
</code></pre>

Zero cost is zero qubits.


<h3 id="__ne__"><code>__ne__</code></h3>

<pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link">
<code>__ne__(
    other
)
</code></pre>

Check equality and either forward a NotImplemented or return the result negated.


<h3 id="__eq__"><code>__eq__</code></h3>

<pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link">
<code>__eq__(
    other
)
</code></pre>

Method generated by attrs for class QubitCount.




