#  Copyright 2023 Google LLC
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      https://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

"""Autogeneration of stub Jupyter notebooks."""

import abc
import inspect
import io
import re
import textwrap
from pathlib import Path
from types import ModuleType
from typing import List, Optional, Tuple

import nbformat
from attrs import field, frozen

from qualtran import BloqDocSpec, BloqExample

from .parse_docstrings import get_markdown_docstring_lines

_IMPORTS = """\
from qualtran import Bloq, CompositeBloq, BloqBuilder, Signature, Register
from qualtran import QBit, QInt, QUInt, QAny
from qualtran.drawing import show_bloq, show_call_graph, show_counts_sigma
from typing import *
import numpy as np
import sympy
import cirq\
"""

_BLOQ_DISPLAY = """\
{lines}
bloq = {obj_expression}
show_bloq(bloq)\
"""

_K_CQ_AUTOGEN = 'cq.autogen'
"""The jupyter metadata key we use to identify cells we've autogenerated.

We use the letters "cq" for historical reasons.
"""


@frozen(kw_only=True)
class NotebookSpecV2:
    """Specification for rendering a jupyter notebook for a given module.

    Attributes:
        title: The title of the notebook
        module: The module it documents. This is used to render the module docstring
            at the top of the notebook.
        bloq_specs: A list of gate or bloq specs.
    """

    title: str
    module: ModuleType
    bloq_specs: List[BloqDocSpec]
    directory: str = field()
    _path_stem: Optional[str] = None

    @directory.default
    def _default_directory(self) -> str:
        path = self.module.__file__
        assert path is not None
        return str(Path(path).parent)

    @property
    def path_stem(self):
        if self._path_stem is None:
            return self.module.__name__.split('.')[-1]
        return self._path_stem

    @property
    def path(self) -> Path:
        return Path(self.directory) / f'{self.path_stem}.ipynb'


def _get_bloq_example_source_lines(bloq_ex: 'BloqExample') -> List[str]:
    """Parse out the source code from a factory function, so we can render it into a cell.

    Args:
        func: The factory function. Its definition must be one line; its body must be
            indented with four spaces; and it must end with a top-level return statement that
            is one line.

    Returns:
        trimmed_lines: The un-indented body of the function without the return statement.
        obj_expression: The expression used in the terminal `return` statement.
    """
    source = textwrap.dedent(inspect.getsource(bloq_ex._func))

    # Usually, our bloq examples are constructed via functions annotated with the `@bloq_example`
    # annotation. If you want to find just the annotation: I develoepd this regex:
    # ma = re.match(r'@bloq_example.*?(?=^def)', source, flags=re.MULTILINE | re.DOTALL)
    #
    # Instead, we'll just strip anything until we find a `def(...) -> xxx:` line.
    # Regex explanation:
    #   - Non-greedy match any character until we get to def
    #   - Non-greedy match any character until we get to a return-type annotation
    #   - Non-greedy match any character until we get to the end of the type annotation
    ma = re.match(r'^.*?def .*?\) -> .*?:\n', source, flags=re.MULTILINE | re.DOTALL)
    if ma is None:
        raise ValueError(f"{bloq_ex.name} function source was not in the form we expected.")
    def_start, body_start = ma.span()
    assert def_start == 0, 'The regex failed to trim off the function definition'
    lines = source[body_start:].splitlines()

    trimmed_lines = []
    for line in lines:
        if not (line == '' or line.startswith(' ' * 4)):
            raise ValueError(f"Bad indentation in {bloq_ex}: {line}")

        trimmed_line = line[4:]
        if trimmed_line.startswith('return '):
            break
        trimmed_lines.append(line[4:])

    return trimmed_lines


class _Cell(metaclass=abc.ABCMeta):
    """Base class for a jupyter notebook cell with our metadata."""

    @property
    @abc.abstractmethod
    def cell_id(self) -> str:
        """A notebook-unique identifier for this cell.

        This is so we can identify and replace autogenerated content.
        """


@frozen
class _MarkdownCell(_Cell):
    """A jupyter notebook cell containing markdown."""

    text: str
    cell_id: str


@frozen
class _PyCell(_Cell):
    """A jupyter notebook cell containing python code."""

    text: str
    cell_id: str


def get_bloq_doc_cells(bloqdoc: BloqDocSpec, cid_prefix: str) -> List[_Cell]:
    """Cells introducing the `bloq_cls`"""

    md_doc: str = '\n'.join(get_markdown_docstring_lines(bloqdoc.bloq_cls))
    py_import: str = bloqdoc.import_line

    return [
        _MarkdownCell(text=md_doc, cell_id=f'{cid_prefix}.bloq_doc.md'),
        _PyCell(text=py_import, cell_id=f'{cid_prefix}.bloq_doc.py'),
    ]


def _get_one_ex_instance_cell(bloq_ex: BloqExample, cid_prefix):
    """Code cell for one example instance."""
    return _PyCell(
        text='\n'.join(_get_bloq_example_source_lines(bloq_ex)),
        cell_id=f'{cid_prefix}.{bloq_ex.name}',
    )


def get_example_instances_cells(bloqdoc: BloqDocSpec, cid_prefix: str) -> List[_Cell]:
    """Cells constructing example instances of the bloq class."""
    examples = bloqdoc.examples
    if not examples:
        return []

    cells: List[_Cell] = [
        _MarkdownCell('### Example Instances', cell_id=f'{cid_prefix}.example_instances.md')
    ]
    return cells + [_get_one_ex_instance_cell(ex, cid_prefix) for ex in examples]


def get_graphical_signature_cells(bloqdoc: BloqDocSpec, cid_prefix: str) -> List[_Cell]:
    """Cells showing a 'graphical signature' for the bloq examples."""
    if not bloqdoc.examples:
        return []

    varnames = [f'{ex.name}' for ex in bloqdoc.examples]
    comma_varnames = ', '.join(varnames)
    comma_str_varnames = ', '.join(f"'`{vn}`'" for vn in varnames)
    newline = '\n' + (' ' * len('show_bloqs('))
    code = 'from qualtran.drawing import show_bloqs\n'
    code += f'show_bloqs([{comma_varnames}],{newline}[{comma_str_varnames}])'
    return [
        _MarkdownCell(
            text='#### Graphical Signature', cell_id=f'{cid_prefix}.graphical_signature.md'
        ),
        _PyCell(text=code, cell_id=f'{cid_prefix}.graphical_signature.py'),
    ]


def get_call_graph_cells(bloqdoc: BloqDocSpec, cid_prefix: str) -> List[_Cell]:
    """Cells showing a call graph for one of the bloq examples."""
    if bloqdoc.call_graph_example is None:
        return []

    ex = bloqdoc.call_graph_example
    graphvar = f'{ex.name}_g'
    sigmavar = f'{ex.name}_sigma'

    code = [
        'from qualtran.resource_counting.generalizers import ignore_split_join',
        f'{graphvar}, {sigmavar} = {ex.name}.call_graph(max_depth=1, generalizer=ignore_split_join)',
        f'show_call_graph({graphvar})',
        f'show_counts_sigma({sigmavar})',
    ]

    return [
        _MarkdownCell(text='### Call Graph', cell_id=f'{cid_prefix}.call_graph.md'),
        _PyCell(text='\n'.join(code), cell_id=f'{cid_prefix}.call_graph.py'),
    ]


def get_cells(bloqdoc: BloqDocSpec) -> List[_Cell]:
    cells: List[_Cell] = []
    cid_prefix = f'{bloqdoc.bloq_cls.__name__}'
    cells += get_bloq_doc_cells(bloqdoc, cid_prefix)
    cells += get_example_instances_cells(bloqdoc, cid_prefix)
    cells += get_graphical_signature_cells(bloqdoc, cid_prefix)
    cells += get_call_graph_cells(bloqdoc, cid_prefix)
    return cells


def _md_nbnode(source: str, cqid: str) -> nbformat.NotebookNode:
    """Helper function to return a markdown cell with correct metadata"""
    return nbformat.v4.new_markdown_cell(source, metadata={_K_CQ_AUTOGEN: cqid})


def _code_nbnode(source: str, cqid: str) -> nbformat.NotebookNode:
    """Helper function to return a code cell with correct metadata"""
    return nbformat.v4.new_code_cell(source, metadata={_K_CQ_AUTOGEN: cqid})


def _cell_to_nbnode(cell: _Cell) -> nbformat.NotebookNode:
    """Turn our typed `_Cell` into a `nbformat.NotebookNode` cell."""
    if isinstance(cell, _MarkdownCell):
        return _md_nbnode(cell.text, cell.cell_id)
    elif isinstance(cell, _PyCell):
        return _code_nbnode(cell.text, cell.cell_id)
    else:
        raise ValueError()


def _get_title_lines(title: str, mod: ModuleType) -> List[str]:
    """Return markdown lines for the title cell.

    This consists of the specified title as well as the associated module's docstring.
    """
    lines = [f'# {title}']

    if mod.__doc__ is None:
        return lines

    lines.append('')
    lines += inspect.cleandoc(mod.__doc__).splitlines()
    return lines


def _init_notebook(
    path_stem: str, overwrite=False, directory: str = '.'
) -> Tuple[nbformat.NotebookNode, Path]:
    """Initialize a jupyter notebook.

    If one already exists: load it in. Otherwise, create a new one.

    Args:
        path_stem: The extensionless filename to find the notebook if it exists.
        overwrite: If set, remove any existing notebook and start from scratch.
        directory: The directory in which we look for the filename.
    """

    nb_path = Path(f'{directory}') / f'{path_stem}.ipynb'

    if overwrite:
        nb_path.unlink(missing_ok=True)

    if nb_path.exists():
        print(f'[{path_stem}] Loading existing: {nb_path}')
        with nb_path.open('r') as f:
            return nbformat.read(f, as_version=4), nb_path

    print(f'[{path_stem}] Creating new: {nb_path}')
    nb = nbformat.v4.new_notebook()
    nb['metadata'].update(
        {
            'kernelspec': {'language': 'python', 'name': 'python3', 'display_name': 'Python 3'},
            'language_info': {'name': 'python'},
        }
    )
    return nb, nb_path


class WriteIfDifferent:
    """A file-like object that only writes to disk if the new content
    differs from the existing content.

    Args:
        path: The path to write, which may already exist.
    """

    def __init__(self, path: Path):
        self.path = path
        self._buffer = io.StringIO()

    def write(self, s: str):
        return self._buffer.write(s)

    def writelines(self, lines):
        for line in lines:
            self.write(line)

    def flush(self):
        self._buffer.flush()

    def close(self):
        """Closes the adapter.

        This triggers the comparison of buffered content
        with the disk file's content and writes to disk only if different.
        """
        new_content = self._buffer.getvalue()
        self._buffer.close()

        existing_content = None
        if self.path.is_file():
            with self.path.open('r') as f_read:
                existing_content = f_read.read()
            if new_content == existing_content:
                print(f"{self.path} unchanged.")
                return

        with self.path.open('w') as f_write:
            f_write.write(new_content)

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        self.close()
        # Do not suppress exceptions from the 'with' block body.
        return False

    @property
    def closed(self):
        return self._buffer.closed

    def readable(self):
        """Returns False, as this adapter is write-only like a file from `open('w')`."""
        return False

    def writable(self):
        """Returns True if the adapter is not closed, False otherwise."""
        return self._buffer.writable()

    def seekable(self):
        """Returns False, as this adapter is not seekable like a disk file opened in 'w' mode."""
        return False

    def tell(self):
        """Returns the current stream position in the internal buffer."""
        return self._buffer.tell()

    def truncate(self, size=None):
        """
        Resizes the internal buffer to the given number of bytes.
        If size is not specified, resizes to the current position.
        """
        return self._buffer.truncate(size)


def render_notebook(nbspec: NotebookSpecV2) -> None:
    # 1. get a notebook (existing or empty)
    nb, nb_path = _init_notebook(path_stem=nbspec.path_stem, directory=nbspec.directory)

    # 2. Render all the cells we can render
    cells = {
        'title_cell': _MarkdownCell(
            '\n'.join(_get_title_lines(nbspec.title, nbspec.module)), cell_id='title_cell'
        ),
        'top_imports': _PyCell(_IMPORTS, cell_id='top_imports'),
    }
    for bds in nbspec.bloq_specs:
        cells |= {c.cell_id: c for c in get_cells(bds)}

    # 3. Merge rendered cells into the existing notebook.
    #     -> we use the cells metadata field to match up cells.
    cqids_to_render: List[str] = list(cells.keys())
    for i in range(len(nb.cells)):
        nb_node = nb.cells[i]
        if _K_CQ_AUTOGEN in nb_node.metadata:
            cqid: str = nb_node.metadata[_K_CQ_AUTOGEN]
            new_cell = cells.get(cqid, None)
            if new_cell is None:
                print(f'[{nbspec.path_stem}] Superfluous {cqid} cell.')
                continue
            print(f"[{nbspec.path_stem}] Replacing {cqid} cell.")
            new_nbnode = _cell_to_nbnode(new_cell)
            new_nbnode.id = nb_node.id  # keep id from existing cell
            nb.cells[i] = new_nbnode
            cqids_to_render.remove(cqid)

    # 4. Any rendered cells that weren't already there, append.
    for cqid in cqids_to_render:
        print(f"[{nbspec.path_stem}] Adding {cqid}")
        new_cell = cells[cqid]
        new_nbnode = _cell_to_nbnode(new_cell)
        nb.cells.append(new_nbnode)

    # 5. Write the notebook.
    with WriteIfDifferent(nb_path) as woc:
        nbformat.write(nb, woc)
