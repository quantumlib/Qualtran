from typing import List, Sequence

import cirq
import numpy as np

import cirq_qubitization
from cirq_qubitization.bit_tools import iter_bits
from cirq_qubitization.cirq_infra import testing as cq_testing
from cirq_qubitization.jupyter_tools import execute_notebook


def get_1d_ising_hamiltonian(
    qubits: Sequence[cirq.Qid], j_zz_strength: float = 1.0, gamma_x_strength: float = -1
) -> cirq.PauliSum:
    r"""A one dimensional ising model with periodic boundaries.

    $$
    H = -J\sum_{k=0}^{L-1}\sigma_{k}^{Z}\sigma_{(k+1)\%L}^{Z} + -\Gamma \sum_{k=0}^{L-1}\sigma_{k}^{X}
    $$

    Args:
        qubits: One qubit for each spin site.
        j_zz_strength: The two-body ZZ potential strength, $J$.
        gamma_x_strength: The one-body X potential strength, $\Gamma$.

    Returns:
        cirq.PauliSum representing the Hamiltonian
    """
    n_sites = len(qubits)
    terms = []
    for k in range(n_sites):
        terms.append(
            cirq.PauliString(
                {qubits[k]: cirq.Z, qubits[(k + 1) % n_sites]: cirq.Z}, coefficient=j_zz_strength
            )
        )
        terms.append(cirq.PauliString({qubits[k]: cirq.X}, coefficient=gamma_x_strength))
    return cirq.PauliSum.from_pauli_strings(terms)


def get_1d_ising_lcu_coeffs(
    n_spins: int, j_zz_strength: float = np.pi / 3, gamma_x_strength: float = np.pi / 7
) -> np.ndarray:
    """Get LCU coefficients for a 1d ising Hamiltonian.

    The order of the terms is according to `get_1d_ising_hamiltonian`, namely: ZZ's and X's
    interleaved.
    """
    spins = cirq.LineQubit.range(n_spins)
    ham = get_1d_ising_hamiltonian(spins, j_zz_strength, gamma_x_strength)
    coeffs = np.array([term.coefficient.real for term in ham])
    lcu_coeffs = coeffs / np.sum(coeffs)
    return lcu_coeffs


def test_ising_zero_bitflip_select():
    num_sites = 4
    target_bitsize = num_sites
    num_select_unitaries = 2 * num_sites
    # PBC Ising in 1-D has num_sites ZZ operations and num_sites X operations.
    # Thus 2 * num_sites Pauli ops
    selection_bitsize = int(np.ceil(np.log(num_select_unitaries)))
    all_qubits = cirq.LineQubit.range(2 * selection_bitsize + target_bitsize + 1)
    control, selection, target = (
        all_qubits[0],
        all_qubits[1 : 2 * selection_bitsize : 2],
        all_qubits[2 * selection_bitsize + 1 :],
    )

    # Get dense PauliString Hamiltonian terms
    # right now we only handle positive interaction term values
    ham = get_1d_ising_hamiltonian(target, 1, 1)
    dense_pauli_string_hamiltonian = [tt.dense(target) for tt in ham]
    # built select with unary iteration gate
    op = cirq_qubitization.GenericSelect(
        selection_bitsize=selection_bitsize,
        target_bitsize=target_bitsize,
        select_unitaries=dense_pauli_string_hamiltonian,
        control_val=1,
    ).on(control, *selection, *target)
    circuit = cirq.Circuit(cirq.decompose(op))
    all_qubits = circuit.all_qubits()

    # now we need to have a superposition w.r.t all operators to act on target.
    # Normally this would be generated by a PREPARE circuit but we will
    # build it directly here.
    for selection_integer in range(num_select_unitaries):
        # turn on control bit to activate circuit
        qubit_vals = {x: int(x == control) for x in all_qubits}
        # Initialize selection bits appropriately
        qubit_vals |= zip(selection, iter_bits(selection_integer, selection_bitsize))

        initial_state = [qubit_vals[x] for x in all_qubits]
        for i, pauli_val in enumerate(dense_pauli_string_hamiltonian[selection_integer]):
            if pauli_val == cirq.X:
                # Hamiltonian already defined on correct qubits so just take qid
                qubit_vals[target[i]] = 1
        final_state = [qubit_vals[x] for x in all_qubits]

        cq_testing.assert_circuit_inp_out_cirqsim(circuit, all_qubits, initial_state, final_state)


def test_ising_one_bitflip_select():
    num_sites = 4
    target_bitsize = num_sites
    num_select_unitaries = 2 * num_sites
    # PBC Ising in 1-D has num_sites ZZ operations and num_sites X operations.
    # Thus 2 * num_sites Pauli ops
    selection_bitsize = int(np.ceil(np.log(num_select_unitaries)))
    all_qubits = cirq.LineQubit.range(2 * selection_bitsize + target_bitsize + 1)
    control, selection, target = (
        all_qubits[0],
        all_qubits[1 : 2 * selection_bitsize : 2],
        all_qubits[2 * selection_bitsize + 1 :],
    )

    # Get dense PauliString Hamiltonian terms
    # right now we only handle positive interaction term values
    ham = get_1d_ising_hamiltonian(target, 1, 1)
    dense_pauli_string_hamiltonian = [tt.dense(target) for tt in ham]
    # built select with unary iteration gate
    op = cirq_qubitization.GenericSelect(
        selection_bitsize=selection_bitsize,
        target_bitsize=target_bitsize,
        select_unitaries=dense_pauli_string_hamiltonian,
        control_val=1,
    ).on(control, *selection, *target)
    circuit = cirq.Circuit(cirq.decompose(op))
    all_qubits = circuit.all_qubits()

    # now we need to have a superposition w.r.t all operators to act on target.
    # Normally this would be generated by a PREPARE circuit, but we will
    # build it directly here.
    for selection_integer in range(num_select_unitaries):
        # turn on control bit to activate circuit
        qubit_vals = {x: int(x == control) for x in all_qubits}
        # Initialize selection bits appropriately
        qubit_vals |= zip(selection, iter_bits(selection_integer, selection_bitsize))

        initial_state = [qubit_vals[x] for x in all_qubits]
        for i, pauli_val in enumerate(dense_pauli_string_hamiltonian[selection_integer]):
            if pauli_val == cirq.X:
                # Hamiltonian already defined on correct qubits so just take qid
                qubit_vals[target[i]] = 1
        final_state = [qubit_vals[x] for x in all_qubits]

        cq_testing.assert_circuit_inp_out_cirqsim(circuit, all_qubits, initial_state, final_state)


def _fake_prepare(
    positive_coefficients: np.ndarray, selection_register: List[cirq.Qid]
) -> cirq.OP_TREE:
    pos_coeffs = positive_coefficients.flatten()
    size_hilbert_of_reg = 2 ** len(selection_register)
    assert len(pos_coeffs) <= size_hilbert_of_reg
    # pad to 2**(len(selection_bitsize)) size
    if len(pos_coeffs) < size_hilbert_of_reg:
        pos_coeffs = np.hstack(
            (pos_coeffs, np.array([0] * (size_hilbert_of_reg - len(pos_coeffs))))
        )

    assert np.isclose(pos_coeffs.conj().T @ pos_coeffs, 1.0)
    circuit = cirq.Circuit()
    circuit.append(cirq.StatePreparationChannel(pos_coeffs).on(*selection_register))
    return circuit


def test_select_application_to_eigenstates():
    # To validate the unary iteration correctly applies the Hamiltonian to a state we
    # compare to directly applying Hamiltonian to the initial state.
    #
    # The target register starts in an eigenstate so <L|select|L> = eig / lambda
    sim = cirq.Simulator(dtype=np.complex128)
    num_sites = 4
    target_bitsize = num_sites
    num_select_unitaries = 2 * num_sites
    # PBC Ising in 1-D has num_sites ZZ operations and num_sites X operations.
    # Thus 2 * num_sites Pauli ops
    selection_bitsize = int(np.ceil(np.log(num_select_unitaries)))
    all_qubits = cirq.LineQubit.range(2 * selection_bitsize + target_bitsize + 1)
    control, selection, target = (
        all_qubits[0],
        all_qubits[1 : 2 * selection_bitsize : 2],
        all_qubits[2 * selection_bitsize + 1 :],
    )

    # Get dense PauliString Hamiltonian terms
    # right now we only handle positive interaction term values
    ham = get_1d_ising_hamiltonian(target, 1, 1)
    dense_pauli_string_hamiltonian = [tt.dense(target) for tt in ham]
    # built select with unary iteration gate
    op = cirq_qubitization.GenericSelect(
        selection_bitsize=selection_bitsize,
        target_bitsize=target_bitsize,
        select_unitaries=dense_pauli_string_hamiltonian,
        control_val=1,
    ).on(control, *selection, *target)
    select_circuit = cirq.Circuit(cirq.decompose(op))
    all_qubits = select_circuit.all_qubits()

    coeffs = get_1d_ising_lcu_coeffs(num_sites, 1, 1)
    prep_circuit = _fake_prepare(np.sqrt(coeffs), selection)
    turn_on_control = cirq.Circuit(cirq.X.on(control))

    ising_eigs, ising_wfns = np.linalg.eigh(ham.matrix())
    qubitization_lambda = sum(xx.coefficient.real for xx in dense_pauli_string_hamiltonian)
    for iw_idx, ie in enumerate(ising_eigs):
        eigenstate_prep = cirq.Circuit()
        eigenstate_prep.append(
            cirq.StatePreparationChannel(ising_wfns[:, iw_idx].flatten()).on(*target)
        )

        input_circuit = turn_on_control + prep_circuit + eigenstate_prep
        input_vec = sim.simulate(input_circuit, qubit_order=all_qubits).final_state_vector
        final_circuit = input_circuit + select_circuit
        out_vec = sim.simulate(final_circuit, qubit_order=all_qubits).final_state_vector

        # Overlap of inital_state and SELECT initial_state should be like applying H/lambda
        # which should give (E / lambda) * initial_state
        np.testing.assert_allclose(np.vdot(input_vec, out_vec), ie / qubitization_lambda, atol=1e-8)


def test_notebook():
    execute_notebook('generic_select')
