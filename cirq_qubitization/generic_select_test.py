from typing import List
import numpy as np
import cirq
import cirq_qubitization


class OneDimensionalIsingModel:
    def __init__(self, num_sites, j_zz_interaction=-1, gamma_x_interaction=-1) -> None:
        """
        H = -J\sum_{k=0}^{L-1}sigma_{k}^{Z}sigma_{(k+1)%L}^{Z} + -Gamma \sum_{k=0}^{L-1}sigma_{k}^{X}
        """
        self.num_sites = num_sites
        self.j = j_zz_interaction
        self.gamma = gamma_x_interaction

        self.qop_hamiltonian = None
        self.fermion_ham = None

    def get_pauli_sum(self, qubits: List[cirq.Qid]) -> cirq.PauliSum:
        """
        Construct the Hamiltonian as a PauliSum object

        :param qubits: list of qubits
        :return: cirq.PauliSum representing the Hamiltonian
        """
        cirq_pauli_terms = []
        for k in range(self.num_sites):
            cirq_pauli_terms.append(
                cirq.PauliString(
                    {qubits[k]: cirq.Z, qubits[(k + 1) % self.num_sites]: cirq.Z},
                    coefficient=self.j,
                )
            )
            cirq_pauli_terms.append(
                cirq.PauliString({qubits[k]: cirq.X}, coefficient=self.gamma)
            )
        return cirq.PauliSum().from_pauli_strings(cirq_pauli_terms)


def test_ising_zero_bitflip_select():
    sim = cirq.Simulator(dtype=np.complex128)
    num_sites = 4
    target_register_size = num_sites
    num_select_unitaries = 2 * num_sites
    # PBC Ising in 1-D has num_sites ZZ operations and num_sites X operations.
    # Thus 2 * num_sites Pauli ops
    selection_register_size = int(np.ceil(np.log(num_select_unitaries)))
    all_qubits = cirq.LineQubit.range(
        2 * selection_register_size + target_register_size + 1
    )
    control, selection, ancilla, target = (
        all_qubits[0],
        all_qubits[1 : 2 * selection_register_size : 2],
        all_qubits[2 : 2 * selection_register_size + 1 : 2],
        all_qubits[2 * selection_register_size + 1 :],
    )

    # Get paulistring terms
    # right now we only handle positive interaction term values
    ising_inst = OneDimensionalIsingModel(num_sites, 1, 1)
    pauli_string_hamiltonian = [*ising_inst.get_pauli_sum(target)]
    dense_pauli_string_hamiltonian = [
        tt.dense(target) for tt in pauli_string_hamiltonian
    ]

    # built select with unary iteration gate
    op = cirq_qubitization.GenericSelect(
        selection_register_length=selection_register_size,
        target_register_length=target_register_size,
        select_unitaries=dense_pauli_string_hamiltonian,
    ).on(control, *selection, *ancilla, *target)
    circuit = cirq.Circuit(op)

    # now we need to have a superposition w.r.t all operators to act on target.
    # Normally this would be generated by a PREPARE circuit but we will
    # build it directly here.
    for selection_integer in range(num_select_unitaries):
        svals = [
            int(x) for x in format(selection_integer, f"0{selection_register_size}b")
        ]
        # turn on control bit to activate circuit
        qubit_vals = {x: int(x == control) for x in all_qubits}
        # Initialize selection bits appropriately
        qubit_vals.update({s: sval for s, sval in zip(selection, svals)})

        initial_state = [qubit_vals[x] for x in all_qubits]
        result = sim.simulate(circuit, initial_state=initial_state)
        for qid_key, pauli_val in pauli_string_hamiltonian[
            selection_integer
        ]._qubit_pauli_map.items():
            if pauli_val == cirq.X:
                # Hamiltonian already defined on correct qubits so just take qid
                initial_state[qid_key._x] = 1
        expected_output = "".join(str(x) for x in initial_state)
        assert result.dirac_notation()[1:-1] == expected_output


def test_ising_one_bitflip_select():
    sim = cirq.Simulator(dtype=np.complex128)
    num_sites = 4
    target_register_size = num_sites
    num_select_unitaries = 2 * num_sites
    # PBC Ising in 1-D has num_sites ZZ operations and num_sites X operations.
    # Thus 2 * num_sites Pauli ops
    selection_register_size = int(np.ceil(np.log(num_select_unitaries)))
    all_qubits = cirq.LineQubit.range(
        2 * selection_register_size + target_register_size + 1
    )
    control, selection, ancilla, target = (
        all_qubits[0],
        all_qubits[1 : 2 * selection_register_size : 2],
        all_qubits[2 : 2 * selection_register_size + 1 : 2],
        all_qubits[2 * selection_register_size + 1 :],
    )

    # Get paulistring terms
    # right now we only handle positive interaction term values
    ising_inst = OneDimensionalIsingModel(num_sites, 1, 1)
    pauli_string_hamiltonian = [*ising_inst.get_pauli_sum(target)]
    dense_pauli_string_hamiltonian = [
        tt.dense(target) for tt in pauli_string_hamiltonian
    ]
    # built select with unary iteration gate
    op = cirq_qubitization.GenericSelect(
        selection_register_length=selection_register_size,
        target_register_length=target_register_size,
        select_unitaries=dense_pauli_string_hamiltonian,
    ).on(control, *selection, *ancilla, *target)
    circuit = cirq.Circuit(op)

    # now we need to have a superposition w.r.t all operators to act on target.
    # Normally this would be generated by a PREPARE circuit but we will
    # build it directly here.
    for selection_integer in range(num_select_unitaries):
        svals = [
            int(x) for x in format(selection_integer, f"0{selection_register_size}b")
        ]
        # turn on control bit to activate circuit
        qubit_vals = {x: int(x == control) for x in all_qubits}
        # Initialize selection bits appropriately
        qubit_vals.update({s: sval for s, sval in zip(selection, svals)})
        # flip target register to all 1
        qubit_vals.update({t: 1 for t in target})
        initial_state = [qubit_vals[x] for x in all_qubits]
        result = sim.simulate(circuit, initial_state=initial_state)
        for qid_key, pauli_val in pauli_string_hamiltonian[
            selection_integer
        ]._qubit_pauli_map.items():
            if pauli_val == cirq.X:
                # Hamiltonian already defined on correct qubits so just take qid
                initial_state[qid_key._x] = 0
        expected_output = "".join(str(x) for x in initial_state)
        assert result.dirac_notation()[1:-1] == expected_output


def fake_prepare(
    positive_coefficients: np.ndarray, selection_register: List[cirq.Qid]
) -> cirq.OP_TREE:
    """
    :param selection_register: use a generic gate op to build a synthetic prepare
    """
    pos_coeffs = positive_coefficients.flatten()
    size_hilbert_of_reg = 2 ** len(selection_register)
    assert len(pos_coeffs) <= size_hilbert_of_reg
    # pad to 2**(len(selection_register)) size
    if len(pos_coeffs) < size_hilbert_of_reg:
        pos_coeffs = np.hstack(
            (pos_coeffs, np.array([0] * (size_hilbert_of_reg - len(pos_coeffs))))
        )

    assert np.isclose(pos_coeffs.conj().T @ pos_coeffs, 1.0)
    circuit = cirq.Circuit()
    circuit.append(cirq.StatePreparationChannel(pos_coeffs).on(*selection_register))
    return circuit


def test_select_application_to_eigenstates():
    """
    To validate the unary iteration correctly applying Hamiltonian to the state we
    should compare to directly applying Hamiltonian to the initial state

    Target register starts in an eigenstate so <L|select|L> = eig / lambda
    """
    sim = cirq.Simulator(dtype=np.complex128)
    num_sites = 4
    target_register_size = num_sites
    num_select_unitaries = 2 * num_sites
    # PBC Ising in 1-D has num_sites ZZ operations and num_sites X operations.
    # Thus 2 * num_sites Pauli ops
    selection_register_size = int(np.ceil(np.log(num_select_unitaries)))
    all_qubits = cirq.LineQubit.range(
        2 * selection_register_size + target_register_size + 1
    )
    control, selection, ancilla, target = (
        all_qubits[0],
        all_qubits[1 : 2 * selection_register_size : 2],
        all_qubits[2 : 2 * selection_register_size + 1 : 2],
        all_qubits[2 * selection_register_size + 1 :],
    )

    # Get paulistring terms
    # right now we only handle positive interaction term values
    ising_inst = OneDimensionalIsingModel(num_sites, 1, 1)
    pauli_sum_hamiltonian = ising_inst.get_pauli_sum(target)
    pauli_string_hamiltonian = [*pauli_sum_hamiltonian]
    dense_pauli_string_hamiltonian = [
        tt.dense(target) for tt in pauli_string_hamiltonian
    ]
    qubitization_lambda = sum(
        xx.coefficient.real for xx in dense_pauli_string_hamiltonian
    )

    ising_eigs, ising_wfns = np.linalg.eigh(pauli_sum_hamiltonian.matrix())

    # built select with unary iteration gate
    op = cirq_qubitization.GenericSelect(
        selection_register_length=selection_register_size,
        target_register_length=target_register_size,
        select_unitaries=dense_pauli_string_hamiltonian,
    ).on(control, *selection, *ancilla, *target)
    select_circuit = cirq.Circuit(op)

    coeffs = np.sqrt(
        np.array([xx.coefficient.real for xx in dense_pauli_string_hamiltonian])
        / qubitization_lambda
    )
    prep_circuit = fake_prepare(coeffs, selection)
    turn_on_control = cirq.Circuit(cirq.X.on(control))

    for ie, iw_idx in zip(ising_eigs, range(len(ising_eigs))):
        eigenstate_prep = cirq.Circuit()
        eigenstate_prep.append(
            cirq.StatePreparationChannel(ising_wfns[:, iw_idx].flatten()).on(*target)
        )

        input_circuit = (
            turn_on_control
            + prep_circuit
            + eigenstate_prep
            + cirq.Circuit([cirq.I.on(xx) for xx in ancilla])
        )
        input_vec = sim.simulate(input_circuit).final_state_vector
        final_circuit = input_circuit + select_circuit
        res = sim.simulate(final_circuit)

        # Overlap of inital_state and SELECT initial_state should be like applying H/lambda
        # which should give (E / lambda) * initial_state
        assert np.isclose(
            np.vdot(input_vec, res.final_state_vector), ie / qubitization_lambda
        )
