#  Copyright 2023 Google LLC
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      https://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
from functools import cached_property
from typing import Dict, Set

import numpy as np
import sympy
from attrs import frozen

from qualtran import (
    Bloq,
    bloq_example,
    BloqBuilder,
    BloqDocSpec,
    BoundedQUInt,
    DecomposeTypeError,
    QBit,
    Register,
    Side,
    Signature,
    Soquet,
    SoquetT,
)
from qualtran.bloqs.arithmetic import GreaterThan
from qualtran.bloqs.basic_gates import CSwap
from qualtran.resource_counting import BloqCountT, SympySymbolAllocator
from qualtran.symbolics import bit_length, is_symbolic, SymbolicInt


@frozen
class Comparator(Bloq):
    r"""Compare and potentially swaps two numbers in {0, ... L - 1}.

    Implements $U|a\rangle|b\rangle|0\rangle \rightarrow |\min(a,b)\rangle|\max(a,b)\rangle|a>b\rangle$,

    where $a$ and $b$ are n-qubit quantum registers. On output a and b are
    swapped if a > b. Forms the base primitive for sorting.
    The numbers are represented using $n = \ceil{\log L}$ bits.

    Args:
        L: Upper-bound (excluded) on the input numbers.

    Registers:
        a: A n-bit-sized input register (register a above).
        b: A n-bit-sized input register (register b above).
        out: A single bit output register which will store the result of the comparator.

    References:
        [Improved techniques for preparing eigenstates of fermionic Hamiltonians](https://www.nature.com/articles/s41534-018-0071-5).
        Fig. 1. in main text.
    """

    L: SymbolicInt

    @property
    def signature(self):
        input_dtype = BoundedQUInt(self.bitsize, self.L)
        return Signature(
            [
                Register('a', input_dtype),
                Register('b', input_dtype),
                Register('out', QBit(), side=Side.RIGHT),
            ]
        )

    @property
    def bitsize(self):
        """number of bits to represent the inputs"""
        return bit_length(self.L - 1)

    def pretty_name(self) -> str:
        return "Cmprtr"

    def build_composite_bloq(
        self, bb: 'BloqBuilder', a: 'Soquet', b: 'Soquet'
    ) -> dict[str, 'SoquetT']:
        out = bb.allocate(dtype=QBit())
        a, b, out = bb.add(GreaterThan(self.bitsize, self.bitsize), a=a, b=b, target=out)
        out, a, b = bb.add(CSwap(self.bitsize), ctrl=out, x=a, y=b)
        return {'a': a, 'b': b, 'out': out}


@bloq_example
def _cmp_symb() -> Comparator:
    L = sympy.Symbol('L')
    cmp_symb = Comparator(L=L)
    return cmp_symb


_COMPARATOR_DOC = BloqDocSpec(bloq_cls=Comparator, examples=[_cmp_symb])


@frozen
class ParallelComparators(Bloq):
    """Given k numbers in [0, L), compare every pair that is `offset` apart.

    Args:
        L: Upper-bound (excluded) on the input integers.
        k: size of the input list.
        offset: compare numbers whose indices are offset apart.

    Registers:
        xs: input list of numbers.
        junk (RIGHT): ancilla generated by comparators.
    """

    L: SymbolicInt
    k: SymbolicInt
    offset: SymbolicInt

    @cached_property
    def signature(self) -> Signature:
        return Signature(
            [
                Register("xs", BoundedQUInt(bit_length(self.L - 1), self.L), shape=(self.k,)),
                Register("junk", QBit(), shape=(self.num_comparisons,), side=Side.RIGHT),
            ]
        )

    def is_symbolic(self):
        return is_symbolic(self.L, self.k, self.offset)

    @cached_property
    def num_comparisons(self) -> SymbolicInt:
        return self.k // 2

    def build_composite_bloq(self, bb: 'BloqBuilder', xs: 'SoquetT') -> Dict[str, 'SoquetT']:
        if self.is_symbolic():
            raise DecomposeTypeError(f"Cannot decompose symbolic {self=}")

        comp = Comparator(self.L)

        junk = []
        for start in range(0, self.k, 2 * self.offset):
            for step in range(self.offset):
                i, j = start + step, start + step + self.offset
                if j >= self.k:
                    break
                xs[i], xs[j], anc = bb.add(comp, a=xs[i], b=xs[j])
                junk.append(anc)

        assert len(junk) == self.num_comparisons, f"{len(junk)=}, {self.num_comparisons=}"

        return {'xs': xs, 'junk': np.array(junk)}

    def build_call_graph(self, ssa: 'SympySymbolAllocator') -> Set['BloqCountT']:
        return {(Comparator(self.L), self.num_comparisons)}


@frozen
class BitonicMerge(Bloq):
    r"""Merge two sorted sequences of integers.

    Args:
        L: Upper-bound (excluded) on the input integers.
        k: Number of integers in each half
    """
    L: SymbolicInt
    k: SymbolicInt

    def __attrs_post_init__(self):
        k = self.k
        if not is_symbolic(k):
            assert k >= 1, "length of input lists must be positive"
            # TODO support non-power-of-two input lengths
            assert (k & (k - 1)) == 0, "length of input lists must be a power of 2"

    @cached_property
    def signature(self) -> 'Signature':
        return Signature(
            [
                Register("xs", BoundedQUInt(self.bitsize, self.L), shape=(self.k,), side=Side.LEFT),
                Register("ys", BoundedQUInt(self.bitsize, self.L), shape=(self.k,), side=Side.LEFT),
                Register(
                    "result",
                    BoundedQUInt(self.bitsize, self.L),
                    shape=(self.k * 2,),
                    side=Side.RIGHT,
                ),
                Register("junk", QBit(), shape=(self.num_comparisons,), side=Side.RIGHT),
            ]
        )

    @cached_property
    def bitsize(self) -> SymbolicInt:
        return bit_length(self.L - 1)

    @cached_property
    def num_comparisons(self) -> SymbolicInt:
        return 2 * self.k * bit_length(self.k - 1)

    def is_symbolic(self):
        return is_symbolic(self.L, self.k)

    def build_composite_bloq(self, bb: 'BloqBuilder', **soqs: 'SoquetT') -> dict[str, 'SoquetT']:
        if self.is_symbolic():
            raise DecomposeTypeError(f"Cannot decompose symbolic {self=}")

        k = self.k
        xs, ys = soqs['xs'], soqs['ys']

        first_round_junk = []
        for i in range(k):
            xs[i], ys[k - 1 - i], anc = bb.add(Comparator(self.L), a=xs[i], b=ys[k - 1 - i])
            first_round_junk.append(anc)

        result = np.concatenate([xs, ys])
        logk = bit_length(k - 1)
        assert 2**logk == k

        all_junks = [first_round_junk]
        for log_offset in reversed(range(logk)):
            result, ancs = bb.add(
                ParallelComparators(self.L, self.k * 2, 2**log_offset), xs=result
            )
            all_junks.append(ancs)

        junk = np.concatenate(all_junks)
        assert len(junk) == self.num_comparisons, f"{len(junk)=}, {self.num_comparisons=}"

        return {'result': result, 'junk': np.array(junk)}


@frozen
class BitonicSort(Bloq):
    r"""Sort k numbers in the range {0, ..., L-1}.

    Args:
        L: Upper-bound (excluded) on the input integers.
        k: Number of integers to sort.

    Registers:
        xs: List of k integers we want to sort.

    References:
        [Improved techniques for preparing eigenstates of fermionic Hamiltonians](https://www.nature.com/articles/s41534-018-0071-5).
        Supporting Information Sec. II.
    """

    L: SymbolicInt
    k: SymbolicInt

    def __attrs_post_init__(self):
        k = self.k
        if not is_symbolic(k):
            assert k >= 1, "length of input list must be positive"
            # TODO support non-power-of-two input lengths
            assert (k & (k - 1)) == 0, "length of input list must be a power of 2"

    @property
    def signature(self):
        return Signature(
            [
                Register("xs", BoundedQUInt(self.bitsize, self.L), shape=(self.k,)),
                Register("junk", QBit(), shape=(self.num_comparisons,), side=Side.RIGHT),
            ]
        )

    @cached_property
    def bitsize(self) -> SymbolicInt:
        return bit_length(self.L - 1)

    @cached_property
    def num_comparisons(self) -> SymbolicInt:
        logk = bit_length(self.k - 1)
        return (self.k // 2) * ((logk * (logk + 1)) // 2)

    def pretty_name(self) -> str:
        return "BSort"

    def is_symbolic(self):
        return is_symbolic(self.L, self.k)

    def build_composite_bloq(self, bb: 'BloqBuilder', xs: 'SoquetT') -> dict[str, 'SoquetT']:
        if self.is_symbolic():
            raise DecomposeTypeError(f"Cannot decompose symbolic {self=}")

        if self.k == 1:
            return {'xs': xs, 'junk': np.array([])}

        if self.k == 2:
            xs[0], xs[1], anc = bb.add(Comparator(self.L), a=xs[0], b=xs[1])
            return {'xs': xs, 'junk': np.array([anc])}

        xs_left, junk_left = bb.add(BitonicSort(self.L, self.k // 2), xs=xs[: self.k // 2])
        xs_right, junk_right = bb.add(BitonicSort(self.L, self.k // 2), xs=xs[self.k // 2 :])
        xs, junk_merge = bb.add(BitonicMerge(self.L, self.k // 2), xs=xs_left, ys=xs_right)

        junk = np.concatenate([junk_left, junk_right, junk_merge])
        assert len(junk) == self.num_comparisons, (
            f"{self.k=}, {len(junk)=}, {self.num_comparisons=}, "
            f"{len(junk_left)=}, {len(junk_right)=}, {len(junk_merge)=}"
        )

        return {'xs': xs, 'junk': junk}

    def build_call_graph(self, ssa: 'SympySymbolAllocator') -> set['BloqCountT']:
        return {(Comparator(self.L), self.num_comparisons)}


@bloq_example
def _bitonic_sort() -> BitonicSort:
    L = sympy.Symbol('L')
    bitonic_sort = BitonicSort(L=L, k=4)
    return bitonic_sort


_BITONIC_SORT_DOC = BloqDocSpec(bloq_cls=BitonicSort, examples=[_bitonic_sort])
