"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file

Copyright 2023 Google LLC

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

https://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
"""

import builtins
import collections.abc
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import sys
import typing

if sys.version_info >= (3, 10):
    import typing as typing_extensions
else:
    import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor

class _Function:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _FunctionEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_Function.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    NONE: _Function.ValueType  # 0
    """Each Term has an associated function. A "NONE" function means that the term
    is made up of a single parameter and can not be decomposed further.
    """
    Add: _Function.ValueType  # 1
    Mul: _Function.ValueType  # 2
    Pow: _Function.ValueType  # 3
    Mod: _Function.ValueType  # 4
    Log: _Function.ValueType  # 5
    Floor: _Function.ValueType  # 6
    Ceiling: _Function.ValueType  # 7
    Max: _Function.ValueType  # 8
    Min: _Function.ValueType  # 9
    Sin: _Function.ValueType  # 10
    Cos: _Function.ValueType  # 11
    Tan: _Function.ValueType  # 12
    Log2: _Function.ValueType  # 13

class Function(_Function, metaclass=_FunctionEnumTypeWrapper):
    """A function sympy expression."""

NONE: Function.ValueType  # 0
"""Each Term has an associated function. A "NONE" function means that the term
is made up of a single parameter and can not be decomposed further.
"""
Add: Function.ValueType  # 1
Mul: Function.ValueType  # 2
Pow: Function.ValueType  # 3
Mod: Function.ValueType  # 4
Log: Function.ValueType  # 5
Floor: Function.ValueType  # 6
Ceiling: Function.ValueType  # 7
Max: Function.ValueType  # 8
Min: Function.ValueType  # 9
Sin: Function.ValueType  # 10
Cos: Function.ValueType  # 11
Tan: Function.ValueType  # 12
Log2: Function.ValueType  # 13
global___Function = Function

class _ConstSymbol:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _ConstSymbolEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_ConstSymbol.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    Pi: _ConstSymbol.ValueType  # 0
    E: _ConstSymbol.ValueType  # 1
    EulerGamma: _ConstSymbol.ValueType  # 2
    Infinity: _ConstSymbol.ValueType  # 3
    ImaginaryUnit: _ConstSymbol.ValueType  # 4

class ConstSymbol(_ConstSymbol, metaclass=_ConstSymbolEnumTypeWrapper): ...

Pi: ConstSymbol.ValueType  # 0
E: ConstSymbol.ValueType  # 1
EulerGamma: ConstSymbol.ValueType  # 2
Infinity: ConstSymbol.ValueType  # 3
ImaginaryUnit: ConstSymbol.ValueType  # 4
global___ConstSymbol = ConstSymbol

@typing.final
class Rational(google.protobuf.message.Message):
    """Represents a constant, rational number."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    NUMERATOR_FIELD_NUMBER: builtins.int
    DENOMINATOR_FIELD_NUMBER: builtins.int
    @property
    def numerator(self) -> global___Parameter: ...
    @property
    def denominator(self) -> global___Parameter: ...
    def __init__(
        self,
        *,
        numerator: global___Parameter | None = ...,
        denominator: global___Parameter | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["denominator", b"denominator", "numerator", b"numerator"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["denominator", b"denominator", "numerator", b"numerator"]) -> None: ...

global___Rational = Rational

@typing.final
class Parameter(google.protobuf.message.Message):
    """A single parameter of a sympy expression."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    CONST_INT_FIELD_NUMBER: builtins.int
    SYMBOL_FIELD_NUMBER: builtins.int
    CONST_RAT_FIELD_NUMBER: builtins.int
    CONST_FLOAT_FIELD_NUMBER: builtins.int
    CONST_SYMBOL_FIELD_NUMBER: builtins.int
    const_int: builtins.int
    symbol: builtins.str
    const_float: builtins.float
    const_symbol: global___ConstSymbol.ValueType
    @property
    def const_rat(self) -> global___Rational: ...
    def __init__(
        self,
        *,
        const_int: builtins.int = ...,
        symbol: builtins.str = ...,
        const_rat: global___Rational | None = ...,
        const_float: builtins.float = ...,
        const_symbol: global___ConstSymbol.ValueType = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["const_float", b"const_float", "const_int", b"const_int", "const_rat", b"const_rat", "const_symbol", b"const_symbol", "parameter", b"parameter", "symbol", b"symbol"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["const_float", b"const_float", "const_int", b"const_int", "const_rat", b"const_rat", "const_symbol", b"const_symbol", "parameter", b"parameter", "symbol", b"symbol"]) -> None: ...
    def WhichOneof(self, oneof_group: typing.Literal["parameter", b"parameter"]) -> typing.Literal["const_int", "symbol", "const_rat", "const_float", "const_symbol"] | None: ...

global___Parameter = Parameter

@typing.final
class Operand(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    TERM_FIELD_NUMBER: builtins.int
    PARAMETER_FIELD_NUMBER: builtins.int
    @property
    def term(self) -> global___Term: ...
    @property
    def parameter(self) -> global___Parameter: ...
    def __init__(
        self,
        *,
        term: global___Term | None = ...,
        parameter: global___Parameter | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["operand", b"operand", "parameter", b"parameter", "term", b"term"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["operand", b"operand", "parameter", b"parameter", "term", b"term"]) -> None: ...
    def WhichOneof(self, oneof_group: typing.Literal["operand", b"operand"]) -> typing.Literal["term", "parameter"] | None: ...

global___Operand = Operand

@typing.final
class Term(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    FUNCTION_FIELD_NUMBER: builtins.int
    OPERANDS_FIELD_NUMBER: builtins.int
    function: global___Function.ValueType
    @property
    def operands(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Operand]: ...
    def __init__(
        self,
        *,
        function: global___Function.ValueType = ...,
        operands: collections.abc.Iterable[global___Operand] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["function", b"function", "operands", b"operands"]) -> None: ...

global___Term = Term
